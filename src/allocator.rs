use crate::page::{Addr, Page, PageOffset, Snapshot};
use binrw::{BinRead, BinWrite};
use std::{
    any::{Any, TypeId},
    borrow::Cow,
    cell::{Ref, RefCell, RefMut},
    collections::HashMap,
    fmt::Debug,
    io::Cursor,
    marker::PhantomData,
    mem,
    ops::Range,
    rc::Rc,
};
use thiserror::Error;

const START_ADDR: PageOffset = 4;

#[derive(Error, Debug)]
enum Error {
    #[error("Pointer already initialized")]
    AlreadyInitialized,
}

pub struct Memory {
    page: Page,
    snapshot: Snapshot,
    next_addr: PageOffset,
}

impl Memory {
    fn from(page: Page) -> Self {
        Self {
            page,
            snapshot: Snapshot::default(),
            next_addr: START_ADDR,
        }
    }

    pub fn new() -> Self {
        Self {
            page: Page::new(),
            snapshot: Snapshot::default(),
            next_addr: START_ADDR,
        }
    }

    fn alloc(&mut self, size: usize) -> Addr {
        assert!(size > 0);
        let addr = self.next_addr;
        self.next_addr += size as u32;
        addr
    }

    pub fn write(&mut self, addr: Addr, bytes: &[u8]) {
        self.snapshot.write(addr, bytes)
    }

    pub fn read_uncommited(&self, addr: PageOffset, len: PageOffset) -> Cow<[u8]> {
        self.page.read_uncommited(addr, len, &self.snapshot)
    }

    pub fn commit(&mut self) {
        let snapshot = mem::take(&mut self.snapshot);
        self.page.commit(snapshot);
    }

    pub fn read_static<const N: usize>(&self, offset: PageOffset) -> [u8; N] {
        let mut ret = [0; N];
        let bytes = self.read_uncommited(offset, N as PageOffset);
        for (to, from) in ret.iter_mut().zip(bytes.iter()) {
            *to = *from;
        }
        ret
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn check_simple_allocation() {
        let mut memory = Memory::new();
        let a_ptr = {
            let mut scope = Scope::new(&mut memory);

            let a = scope.create(ListNode {
                value: 42,
                next: Ptr::null(),
            });
            a.ptr()
        };

        let mut scope = Scope::new(&mut memory);
        let handle = scope.lookup(a_ptr);
        assert_eq!(RefCell::borrow(&handle.value).value, 42);
    }

    #[test]
    fn check_complex_allocation() {
        let mut memory = Memory::new();

        let a_ptr = {
            let mut scope = Scope::new(&mut memory);
            let mut b = scope.create(ListNode {
                value: 35,
                next: Ptr::null(),
            });
            let mut a = scope.create(ListNode {
                value: 34,
                next: b.ptr(),
            });
            scope.finish();

            a.ptr()
        };

        let mut scope = Scope::new(&mut memory);
        let list = LinkedList::new(scope, a_ptr);
        assert_eq!(list.len(), 2);
    }
}

#[derive(BinRead, BinWrite)]
struct Ptr<T> {
    addr: u32,
    _phantom: PhantomData<T>,
}

impl<T> Clone for Ptr<T> {
    fn clone(&self) -> Self {
        *self
    }
}

/// Need to implement Copy manually, because derive(Copy) is automatically
/// adding `T: Copy` bound in autogenerated implementation
impl<T> Copy for Ptr<T> {}

impl<T> Ptr<T> {
    fn from_addr(addr: u32) -> Ptr<T> {
        Ptr {
            addr,
            _phantom: PhantomData::<T>,
        }
    }

    fn null() -> Self {
        Self::from_addr(0)
    }

    fn is_null(&self) -> bool {
        self.addr == 0
    }
}

fn borrow_downcast<T: Any>(cell: &RefCell<dyn Any>) -> Option<Ref<T>> {
    let r = cell.borrow();
    if (*r).type_id() == TypeId::of::<T>() {
        Some(Ref::map(r, |x| x.downcast_ref::<T>().unwrap()))
    } else {
        None
    }
}

struct LinkedList<'a> {
    scope: Scope<'a>,
    root: Ptr<ListNode>,
}

#[derive(BinRead, BinWrite, Clone)]
#[brw(little)]
struct ListNode {
    value: i32,
    next: Ptr<ListNode>,
}

impl ServiceEntity for ListNode {
    fn size(&self) -> usize {
        8
    }

    fn write_to(&self, buffer: &mut Cursor<Vec<u8>>) {
        self.write(buffer).unwrap();
    }
}

impl<'a> LinkedList<'a> {
    fn new(scope: Scope<'a>, root: Ptr<ListNode>) -> Self {
        Self { scope, root }
    }

    fn push(&mut self, value: i32) {
        let handle = self.scope.create(ListNode {
            value,
            next: Ptr::null(),
        });
        self.root = handle.ptr();
    }

    fn len(&self) -> usize {
        let mut node: Ptr<_> = self.root;
        let mut len = 0;
        while !node.is_null() {
            // dbg!(node.addr);
            len += 1;
            node = self.scope.lookup(node).as_ref().next;
        }
        len
    }
}

struct Utf8<'a> {
    data: &'a str,
}

struct Scope<'a> {
    memory: &'a mut Memory,
    active_set: RefCell<HashMap<Addr, Rc<RefCell<dyn Any>>>>,
}

impl<'a> Scope<'a> {
    fn new(memory: &'a mut Memory) -> Self {
        Self {
            memory,
            active_set: RefCell::new(HashMap::new()),
        }
    }

    fn lookup<T: BinRead + 'static>(&'a self, ptr: Ptr<T>) -> Handle<T>
    where
        T::Args<'a>: Default,
    {
        use binrw::BinReaderExt;

        let addr = ptr.addr;
        let bytes = self.memory.read_static::<4>(addr);
        let len = u32::from_be_bytes(bytes);
        let bytes = self.memory.read_uncommited(addr + 4, len);
        let mut cursor = Cursor::new(bytes);
        let value: T = cursor.read_ne().unwrap();

        Handle {
            addr,
            value: Rc::new(RefCell::new(value)),
        }
    }

    fn create<T: ServiceEntity>(&mut self, value: T) -> Handle<T> {
        let size = value.size() + 4; // 4 bytes in size
        let addr = self.memory.alloc(size);
        let mut buffer = Cursor::new(Vec::new());
        (size as PageOffset).write_be(&mut buffer);
        value.write_to(&mut buffer);
        self.memory.write(addr, &buffer.into_inner());

        Handle {
            addr,
            value: Rc::new(RefCell::new(value)),
        }
    }

    fn update<T: ServiceEntity>(&mut self, handle: &Handle<T>) {
        let value = RefCell::borrow(&handle.value);
        let size = value.size() + 4; // 4 bytes in size
        let mut buffer = Cursor::new(Vec::new());
        (size as u32).write_be(&mut buffer);
        value.write_to(&mut buffer);
        self.memory.write(handle.addr, &buffer.into_inner());
    }

    fn finish(self) {
        self.memory.commit();
    }
}

struct Handle<T> {
    addr: Addr,
    value: Rc<RefCell<T>>,
}

impl<T> Handle<T> {
    fn as_mut(&mut self) -> RefMut<T> {
        RefCell::borrow_mut(&self.value)
    }

    fn as_ref(&self) -> Ref<T> {
        RefCell::borrow(&self.value)
    }

    fn ptr(&self) -> Ptr<T> {
        Ptr {
            addr: self.addr,
            _phantom: PhantomData::<T>,
        }
    }
}

impl<T: Debug + ServiceEntity + 'static> Handle<T> {
    fn join_handle(&self) -> Box<dyn JoinHandle> {
        Box::new(HandleImpl(Some(Rc::clone(&self.value))))
    }
}

struct HandleImpl<T>(Option<Rc<RefCell<T>>>);

impl<T: Debug + ServiceEntity + 'static> JoinHandle for HandleImpl<T> {
    fn join(&mut self) -> Option<Box<dyn ServiceEntity>> {
        let v = self.0.take().unwrap();
        let entity = Rc::try_unwrap(v).unwrap().into_inner();
        Some(Box::new(entity))
    }
}

trait ServiceEntity {
    fn size(&self) -> usize;
    fn write_to(&self, buffer: &mut Cursor<Vec<u8>>);
}

trait JoinHandle {
    fn join(&mut self) -> Option<Box<dyn ServiceEntity>>;
}
