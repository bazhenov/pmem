use crate::page::{Addr, Page, PageOffset, Snapshot};
use binrw::{BinRead, BinWrite};
use std::{
    borrow::Cow,
    cell::{Ref, RefCell},
    io::{Cursor, Seek, SeekFrom, Write},
    marker::PhantomData,
    rc::Rc,
};
const START_ADDR: PageOffset = 4;

pub struct Memory {
    page: Page,
    next_addr: PageOffset,
    seq: u32,
}

impl Memory {
    pub fn new() -> Self {
        Self {
            page: Page::new(),
            next_addr: START_ADDR,
            seq: 0,
        }
    }

    pub fn change<T>(&mut self, f: impl Fn(&mut Transaction) -> T) -> T {
        let mut tx = self.start();
        let response = f(&mut tx);
        let Transaction {
            snapshot,
            next_addr,
            ..
        } = tx;

        assert!(tx.next_addr >= self.next_addr);
        assert!(tx.seq == self.seq);
        self.seq += 1;
        self.next_addr = next_addr;
        self.page.commit(snapshot);
        response
    }

    pub fn start(&self) -> Transaction {
        Transaction {
            memory: self,
            snapshot: Snapshot::default(),
            next_addr: self.next_addr,
            seq: self.seq,
        }
    }
}

pub struct Transaction<'a> {
    memory: &'a Memory,
    snapshot: Snapshot,
    next_addr: Addr,
    seq: u32,
}

impl<'a> Transaction<'a> {
    pub fn write_bytes(&mut self, addr: Addr, bytes: &[u8]) {
        self.snapshot.write(addr, bytes)
    }

    pub fn read(&self, addr: PageOffset, len: PageOffset) -> Cow<[u8]> {
        self.memory.page.read_uncommited(addr, len, &self.snapshot)
    }

    pub fn lookup<T>(&self, ptr: Ptr<T>) -> Handle<T>
    where
        T: BinRead<Args<'a> = ()> + 'static,
    {
        use binrw::BinReaderExt;

        let addr = ptr.addr;
        let bytes = self.read_static::<4>(addr);
        let len = u32::from_be_bytes(bytes);
        let bytes = self.read_uncommited(addr + 4, len);
        let mut cursor = Cursor::new(bytes);
        let value: T = cursor.read_ne().unwrap();

        Handle {
            addr,
            value: Rc::new(RefCell::new(value)),
        }
    }

    fn read_static<const N: usize>(&self, offset: PageOffset) -> [u8; N] {
        let mut ret = [0; N];
        let bytes = self.read_uncommited(offset, N as PageOffset);
        for (to, from) in ret.iter_mut().zip(bytes.iter()) {
            *to = *from;
        }
        ret
    }

    fn read_uncommited(&self, addr: PageOffset, len: PageOffset) -> Cow<[u8]> {
        self.memory.page.read_uncommited(addr, len, &self.snapshot)
    }

    fn alloc(&mut self, size: usize) -> Addr {
        assert!(size > 0);
        let addr = self.next_addr;
        self.next_addr += size as u32;
        addr
    }

    pub fn write<T: ServiceEntity>(&mut self, value: T) -> Handle<T> {
        let addr = self.write_at(&value, None).addr;

        Handle {
            addr,
            value: Rc::new(RefCell::new(value)),
        }
    }

    fn write_at<T: ServiceEntity>(&mut self, value: &T, ptr: Option<Ptr<T>>) -> Ptr<T> {
        let mut buffer = Cursor::new(Vec::new());
        buffer.write_all(&[0, 0, 0, 0]).unwrap();
        // reserving 4 bytes at the begining of the block
        value.write_to(&mut buffer);
        let size = buffer.position() as usize;
        let ptr = ptr.unwrap_or_else(|| Ptr {
            addr: self.alloc(size),
            _phantom: PhantomData::<T>,
        });

        buffer.seek(SeekFrom::Start(0)).unwrap();
        (size as PageOffset).write_be(&mut buffer).unwrap();
        // writing object size
        let buffer = buffer.into_inner();

        self.write_bytes(ptr.addr, &buffer);
        ptr
    }

    pub fn update<T: ServiceEntity>(&mut self, handle: &Handle<T>) {
        let value = RefCell::borrow(&handle.value);
        self.write_at(&*value, Some(handle.ptr()));
    }
}

#[derive(BinRead, BinWrite)]
pub struct Ptr<T> {
    addr: u32,
    _phantom: PhantomData<T>,
}

impl<T> Clone for Ptr<T> {
    fn clone(&self) -> Self {
        *self
    }
}

/// Need to implement Copy manually, because derive(Copy) is automatically
/// adding `T: Copy` bound in autogenerated implementation
impl<T> Copy for Ptr<T> {}

impl<T> Ptr<T> {
    fn from_addr(addr: u32) -> Ptr<T> {
        Ptr {
            addr,
            _phantom: PhantomData::<T>,
        }
    }

    pub fn null() -> Self {
        Self::from_addr(0)
    }

    pub fn is_null(&self) -> bool {
        self.addr == 0
    }
}

pub struct Handle<T> {
    addr: Addr,
    value: Rc<RefCell<T>>,
}

impl<T> Handle<T> {
    pub fn as_ref(&self) -> Ref<T> {
        RefCell::borrow(&self.value)
    }

    pub fn ptr(&self) -> Ptr<T> {
        Ptr {
            addr: self.addr,
            _phantom: PhantomData::<T>,
        }
    }
}

pub trait ServiceEntity {
    fn write_to(&self, buffer: &mut Cursor<Vec<u8>>);
}
